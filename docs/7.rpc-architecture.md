# RPC vs CQRS Architecture Guide

## Overview

The Financy application uses two complementary patterns for handling different types of operations:

- **RPC (Remote Procedure Call)**: For client-server communication over WebSockets
- **CQRS (Command Query Responsibility Segregation)**: For internal backend workflows and business logic

## When to Use What

### Use RPC for:
- **Client-Server Communication**: All operations initiated by the frontend
- **WebSocket Messages**: Real-time bidirectional communication
- **API-like Operations**: Create, read, update, delete operations
- **Input Validation**: Validating data from untrusted sources (frontend)
- **Type Safety**: Ensuring type-safe communication between frontend and backend

### Use CQRS for:
- **Internal Backend Workflows**: Operations triggered by other backend operations
- **Business Logic**: Complex domain operations that require multiple steps
- **Event-Driven Architecture**: Handling side effects of operations
- **Background Processes**: Automated tasks, notifications, cleanup operations

## Architecture Flow

```
Frontend â†’ RPC â†’ Backend Handler â†’ CQRS Commands/Events â†’ Database/External Services
```

### Example: Creating a Transaction

1. **Frontend** sends RPC message:
   ```json
   {
     "rpc": "TransactionCreateCommand",
     "p": { "transaction": { "accountId": 1, "amount": 100, "type": 2 } },
     "id": "abc123"
   }
   ```

2. **RPC Handler** validates input and processes request:
   ```typescript
   export const transactionCreateHandler: RPCHandler = async (payload, context) => {
     // Validate permissions
     // Create transaction in database
     // Emit CQRS events for side effects
     eventBus.emit(new TransactionCreatedEvent({ transaction }))
     return { success: true, data: transaction }
   }
   ```

3. **CQRS Event Handlers** handle side effects:
   ```typescript
   // Update account balance
   // Send WebSocket notifications to other users
   // Update analytics
   // Send push notifications
   ```

## RPC Message Format

### Request
```typescript
interface WebSocketRPCRequest {
  rpc: string        // RPC operation name (e.g., "TransactionCreateCommand")
  p: unknown         // Payload data
  id: string         // Acknowledgment ID for response correlation
}
```

### Response
```typescript
interface WebSocketRPCResponse {
  id: string         // Acknowledgment ID from request
  success: boolean   // Success flag
  data?: unknown     // Response data (if successful)
  error?: unknown    // Error information (if failed)
}
```

## RPC Implementation Pattern

### 1. Define RPC Operation
```typescript
// libs/shared/rpc/transaction.ts
export interface TransactionCreatePayload {
  transaction: TransactionBase
}

export interface TransactionCreateResult {
  id: number
  // ... other fields
}

export interface TransactionCreateError {
  code: string
  message: string
  details?: Record<string, unknown>
}

export const TransactionCreateCommand: RPCClass = {
  name: "TransactionCreateCommand",
  payloadSchema: (data) => /* validation logic */,
  resultSchema: (data) => /* validation logic */,
  errorSchema: (data) => /* validation logic */,
  prepare: (payload) => ({ rpc: "TransactionCreateCommand", p: payload, id: getRandomString(12) }),
}
```

### 2. Implement Handler
```typescript
// apps/api/rpc/transaction-create.ts
export const transactionCreateHandler: RPCHandler = async (payload, context) => {
  try {
    // Validate permissions
    // Process business logic
    // Return typed result
    return { success: true, data: result }
  } catch (error) {
    return { success: false, error: { code: "ERROR", message: error.message } }
  }
}
```

### 3. Register Handler
```typescript
// apps/api/routes/websockets/router.ts
rpcBus.register(TransactionCreateCommand, transactionCreateHandler)
```

### 4. Frontend Usage
```typescript
// Frontend code
const response = await ws.request(TransactionCreateCommand.prepare({ transaction: data }))
if (response.success) {
  console.log("Transaction created:", response.data)
} else {
  console.error("Error:", response.error)
}
```

## File Organization

### RPC Files
- `libs/shared/rpc/types.ts` - Core RPC interfaces and types
- `libs/shared/rpc/bus.ts` - RPC bus for registration and execution
- `libs/shared/rpc/transaction.ts` - Transaction RPC operations
- `libs/shared/rpc/category.ts` - Category RPC operations (to be created)
- `apps/api/rpc/transaction-create.ts` - Transaction create handler
- `apps/api/rpc/transaction-update.ts` - Transaction update handler (to be created)

### CQRS Files (Legacy)
- `libs/shared/cqrs/types.ts` - CQRS interfaces (for internal use)
- `apps/api/cqrs/events.ts` - Domain events
- `apps/api/cqrs/event-handlers/` - Event handlers for side effects

## Migration Strategy

1. âœ… **Phase 1**: Create new RPC system alongside existing CQRS
2. ðŸ”„ **Phase 2**: Migrate WebSocket handlers to use RPC (in progress)
3. **Phase 3**: Migrate all client-server operations to RPC
4. **Phase 4**: Keep CQRS for internal workflows only
5. **Phase 5**: Remove legacy WebSocket message format

## Key Benefits

- **Type Safety**: Full type safety from frontend to backend
- **Clear Separation**: RPC for external API, CQRS for internal logic
- **Better Testing**: One handler per file, no barrel imports
- **Validation**: Input validation at the RPC layer
- **Error Handling**: Structured error responses
- **Documentation**: Self-documenting through TypeScript interfaces

## Best Practices

### RPC Handlers
- One handler per file (no barrel imports)
- Always validate permissions in context
- Use meaningful error codes and messages
- Emit CQRS events for side effects
- Keep handlers focused on a single operation

### Error Handling
- Use structured error objects with codes
- Include helpful error messages
- Provide validation details when appropriate
- Log errors for debugging

### Validation
- Validate all inputs at RPC layer
- Use ArkType for schema validation
- Return meaningful validation errors
- Don't trust any data from the frontend

### Performance
- Cache frequently accessed data
- Use database transactions for consistency
- Batch operations when possible
- Consider pagination for large datasets
